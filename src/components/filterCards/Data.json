{
  "records": [
      {
          "id": "rec1NLCRTTolKRkba",
          "createdTime": "2023-01-03T14:50:50.000Z",
          "fields": {
              "Example": "Valid uses of the \"!\" to indicate that a field or list can't be null applied to fields and lists.\n\nString! - returns a string that can't be null\n[Words] - returns a list and can return a null list or null members.\n[Words!] - returns a list that can be null but its members can't be\n[Words]!- returns a list that can't be null but its members can return null\n[Words!]!- returns a list that can't be null and can't have null members\n",
              "Description": "Nullability in GraphQL is the designation of a field or list as returning a null value or not. Fields that are nonnull or where null is not an acceptable response are identified with an exclamation mark.\n",
              "Term": "DUMMY DATA Nullability",
              "Tags": [
                  "nonnull",
                  "null"
              ]
          }
      },
      {
          "id": "rec2KXGE09ELJZgei",
          "createdTime": "2022-12-14T12:37:34.000Z",
          "fields": {
              "Term": "DUMMY DATA Federation"
          }
      },
      {
          "id": "rec51ZynGYzsMpRhU",
          "createdTime": "2023-01-03T14:50:07.000Z",
          "fields": {
              "Example": "schema\n`type Mutation {`\n`  createUser(name: String!, email: String!): User`\n`  updateUser(id: ID!, name: String, email: String): User`\n`  deleteUser(id: ID!): User`\n```\n}\n```\n",
              "Description": "A mutation is a write operation followed by a fetch. It enables the user to mutate (add, update, or delete) specified fields and then query the modified value on the object returned. \n",
              "Term": "DUMMY DATA Mutation",
              "Tags": [
                  "graphql",
                  "operation"
              ]
          }
      },
      {
          "id": "rec6iwgldViSR3XVP",
          "createdTime": "2023-01-03T14:50:18.000Z",
          "fields": {
              "Example": "```\nsubscription onFilmAdded(id: ID!, filmID: ID) {\n  filmAdded(id: $id, filmID: $filmID) {\n    title\n  }\n}\n```\n",
              "Description": "A subscription is a type of operation that allows a client to receive real-time updates from a server by establishing a long-running connection. When the server's data changes, the server can push updates to the subscribed client through this connection.\n",
              "Term": "Subscription",
              "Tags": [
                  "graphql",
                  "operation"
              ]
          }
      },
      {
          "id": "rec7ttBXzOi11O3QF",
          "createdTime": "2022-12-14T12:37:34.000Z",
          "fields": {
              "Example": "`type Post @model @auth(rules: [`\n`    { allow: private, operations: [read] },`\n`    { allow: groups, groups: [\"admin\"] }.`\n`    { allow: owner, ownerField: \"author\" }]`\n`]) {`\n`    id: ID!`\n`    title: String!`\n`    author: String!`\n`}`\n",
              "Description": "Permissions in GraphQL can be specified at the query level, object level, or field level. \n",
              "Source article, video, documentation, etc.": "https://graphql.org/learn/authorization/",
              "Term": "DUMMY DATA Field Level Authorization",
              "Tags": [
                  "Authorization",
                  "permissions",
                  "field-level"
              ]
          }
      },
      {
          "id": "rec7wzuWunPxExW3f",
          "createdTime": "2023-01-03T14:56:20.000Z",
          "fields": {
              "Example": "// Subscribe to real-time updates on the current temperature in a city\nconst query = \\`\n  subscription {\n    temperature(city: \"San Francisco\")\n  }\n\\`;\n\n// Create a function to handle updates from the server\nconst handleUpdate = (temperature) => {\n  console.log(\\`The temperature in San Francisco is now ${temperature}°F\\`);\n};\n\n// Send the subscription request to the server and pass the update handler function\nclient.subscribe({ query, handleUpdate });\n\n",
              "Description": "GraphQL live queries allow a client to subscribe to real-time updates from a GraphQL server. Instead of making a request to the server and receiving a one-time response, the client can establish a long-running connection with the server and receive updates in real time as they happen.\n",
              "Term": "DUMMY DATA Live Queries",
              "Tags": [
                  "subcription",
                  "real-time",
                  "non-spec"
              ]
          }
      },
      {
          "id": "rec8Sl8LTNgJ4uuOo",
          "createdTime": "2023-01-03T15:00:11.000Z",
          "fields": {
              "Example": "Sending a query to a GraphQL API using the \"\\_\\_schema\" will return type information about a named object or all of the types in a GraphQL schema.\n\n{\n \\_\\_schema {\n  types {\n     name\n  }\n }\n}\n\n\n",
              "Description": "Introspection is the capability of returning parts of a schema or the full schema from a GraphQL API using a special client query.\n",
              "Term": "DUMMY DATA Introspection",
              "Tags": [
                  "graphql",
                  "schema"
              ]
          }
      },
      {
          "id": "rec9ffqNZ0NVTNYgH",
          "createdTime": "2023-01-24T14:18:06.000Z",
          "fields": {
              "Description": "ID\n",
              "Term": "DUMMY DATA Global Object Identification"
          }
      },
      {
          "id": "recAs87f6TyjYYUre",
          "createdTime": "2023-02-04T06:25:33.000Z",
          "fields": {
              "Example": "The most frequently used mock server is called GraphQL Faker.\n\nGraphQL Faker exposes 3 endpoints\n1. /editor - an interactive editor for writing queries\n2. /graphql - the interface to your GraphQL API\n3. /voyager - an interactive display of your API which reveals the relationships and dependencies between types.  \n\n",
              "Description": "Mock servers are \"fake\" servers that mimic the behavior of a real server. They are commonly used for developing API clients which the backend is under development. You can launch a mock server using the specification for an API. Mock servers return fake data and typically don't persist data.\n",
              "Source article, video, documentation, etc.": "https://github.com/APIs-guru/graphql-faker",
              "Term": "DUMMY DATA Mock Server"
          }
      },
      {
          "id": "recIpVGl3WmMRSWaO",
          "createdTime": "2023-01-03T14:50:29.000Z",
          "fields": {
              "Description": "A GraphQL schema is a list of object types that define all of the data available to clients of the API.\n",
              "Term": "DUMMY DATA Schema",
              "Tags": [
                  "api",
                  "graphql",
                  "schema"
              ]
          }
      },
      {
          "id": "recJfP3l8DR9EiVrn",
          "createdTime": "2023-01-03T15:01:06.000Z",
          "fields": {
              "Term": "SSE - Server Side Events ?"
          }
      },
      {
          "id": "recLNYAztp5ee04gK",
          "createdTime": "2023-01-03T14:55:12.000Z",
          "fields": {
              "Term": "DUMMY DATA Persisted Queries"
          }
      },
      {
          "id": "recO8743dNruOjDXL",
          "createdTime": "2023-01-03T14:50:42.000Z",
          "fields": {
              "Description": "A function that returns a value for a field with types of a GraphQL schema. Each field in a GraphQL schema has a corresponding resolver to return the value of that field.\n",
              "Term": "DUMMY DATA Resolver"
          }
      },
      {
          "id": "recOjO0VGH362drF0",
          "createdTime": "2023-01-03T14:53:29.000Z",
          "fields": {
              "Term": "DUMMY DATA Node"
          }
      },
      {
          "id": "recQxbPEfmdWXQrEU",
          "createdTime": "2023-01-03T14:53:18.000Z",
          "fields": {
              "Example": "The core GraphQL specification includes directives such as `@skip`, `@include` and `@deprecated`.\n",
              "Description": "A directive can be applied to a field to instruct a resolver function on how to execute that query. \n\n",
              "Term": "DUMMY DATA Directive",
              "Tags": [
                  "graphql",
                  "directive"
              ]
          }
      },
      {
          "id": "recSmscXlpe90LlJh",
          "createdTime": "2023-01-03T14:55:34.000Z",
          "fields": {
              "Example": "A GraphQL engine is a runtime for executing GraphQL queries. It consists of the following main components:\n1. **Schema**: The schema defines the shape of the data that can be queried and the relationships between different types of data. It specifies the types of queries that can be executed and the fields that can be queried within those types.\n2. **Resolvers**: Resolvers are functions that are responsible for executing a particular field in the schema. When a field is queried, the corresponding resolver is called to retrieve the data for that field.\n3. **Data sources**: Data sources are the underlying systems that provide the data that is being queried. These could be databases, APIs, or any other source of data.\n4. **Cache**: A cache is used to store the results of previous queries to improve the performance of subsequent requests.\n5. **Execution engine**: The execution engine is responsible for executing the GraphQL query by calling the appropriate resolvers and combining the results into a single response. It also applies any transformations or data manipulation that is specified in the query.\n\n\n\n",
              "Description": "GraphQL is only a specification. The GraphQL engine refers to an implementation of this specification.\n\n\n",
              "Term": "DUMMY DATA GraphQL Engine",
              "Tags": [
                  "graphql",
                  "implementation"
              ]
          }
      },
      {
          "id": "recU3MJ3ZKLWSDjbC",
          "createdTime": "2023-01-03T14:58:37.000Z",
          "fields": {
              "Example": "const { request } = require('graphql-request');\n\nconst ENDPOINT = 'https://your-graphql-server.com/graphql';\n\nasync function getUsers() {\n  const query = \\`\n    query {\n      users {\n        id\n        name\n        posts {\n          title\n        }\n      }\n    }\n  \\`;\n\n  const data = await request(ENDPOINT, query);\n  return data.users;\n}\n\nasync function main() {\n  const users = await getUsers();\n\n  // Here, we will make one additional request for each user's posts\n  for (const user of users) {\n    console.log(\\`${user.name} has ${user.posts.length} posts:\\`);\n    for (const post of user.posts) {\n      console.log(post.title);\n    }\n  }\n}\n\nmain();\n\n\n\n",
              "Description": "Batching is a technique that is used with GraphQL to resolve the N + 1 problem. The N+1 problem refers to the issue that can occur when the server makes one request for the initial data set, and then makes additional requests for each related item in the data set.  The DataLoader library is the most common batching and caching solution used with GraphQL.\n",
              "Term": "DUMMY DATA Batching",
              "Tags": [
                  "performance",
                  "graphql",
                  "N +1 problem"
              ]
          }
      },
      {
          "id": "recY72E9QRqx7nkQ0",
          "createdTime": "2023-01-03T14:49:38.000Z",
          "fields": {
              "Term": "DUMMY DATA Sub Graph"
          }
      },
      {
          "id": "recZpqPhok9qYO5Pq",
          "createdTime": "2023-01-03T14:54:36.000Z",
          "fields": {
              "Term": "DUMMY DATA Object Level Authorization"
          }
      },
      {
          "id": "recf39CPKI2x16tt1",
          "createdTime": "2022-12-14T12:37:34.000Z",
          "fields": {
              "Description": "\n",
              "Term": "Schema Polymorphism",
              "Tags": [
                  "schema",
                  "inheritance"
              ]
          }
      },
      {
          "id": "rechJPwkJ6FfGqNnw",
          "createdTime": "2023-01-03T14:53:08.000Z",
          "fields": {
              "Example": "The three types of GraphQL operations are queries, mutations, and subscriptions.\n",
              "Description": "An operation describes the actions executed by the GraphQL API. GraphQL supports three types of operations.\t\t\n",
              "Term": "Operation",
              "Tags": [
                  "graphql",
                  "operation"
              ]
          }
      },
      {
          "id": "rechb45RHEUFgvIDF",
          "createdTime": "2023-01-04T14:15:46.000Z",
          "fields": {
              "Example": "\n- `Int`: A signed 32‐bit integer.\n- `Float`: A signed double-precision floating-point value.\n- `String`: A UTF‐8 character sequence.\n- `Boolean`: `true` or `false`.\n- `ID`: The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an `ID` signifies that it is not intended to be human‐readable.\n\n",
              "Description": "GraphQL specifies a list of scalar types to identify the data structure of an object field. The list of built-in scalars is given in the Example below.\n",
              "Term": "Scalar Type",
              "Tags": [
                  "schema",
                  "scalars"
              ]
          }
      },
      {
          "id": "recioPRS0kZXOIGmJ",
          "createdTime": "2023-01-03T14:51:54.000Z",
          "fields": {
              "Example": "The input type `PersonInput` for example, has been utilized in both the query and the mutation instead of individually specifying age and name parameters for both. \n\n`input PersonInput {`\n` name: String!`\n` age: Int`\n`}`\n\n`''' Says hello to the specified person '''`\n`type Query {`\n`  hello(person: PersonInput): String!`\n`}`\n\n`type Mutation {`\n`  createPerson(person: PersonInput!): Person!`\n`}`\n",
              "Description": "The `input` keyword is used to describe an object that may be used as an input parameter. Instead of duplicating each individual argument, this object may be reused across different operations.\n",
              "Term": "Input Type",
              "Tags": [
                  "type"
              ]
          }
      },
      {
          "id": "recjI7avdFuqS8viD",
          "createdTime": "2023-01-03T14:55:24.000Z",
          "fields": {
              "Term": "Caching"
          }
      },
      {
          "id": "reckOoNHPWv1RnW8F",
          "createdTime": "2023-01-03T14:51:47.000Z",
          "fields": {
              "Term": "Interface"
          }
      },
      {
          "id": "reclfE1X9HVMMMrpp",
          "createdTime": "2023-01-03T14:49:59.000Z",
          "fields": {
              "Example": "```\n\"\"\"client query\"\"\"\n\n\"\"\"schema query type\"\"\"\ntype Query {\n  users: [User]\n  user(id: ID!): User\n}\n```\n",
              "Description": "A query is a read-only operation. It enables the user to request specific fields from objects and receive only those fields, avoiding over- or under-fetching.\n\"\"\"Cover both schema description and client description.\"\"\"\n",
              "Term": "Query",
              "Tags": [
                  "graphql",
                  "operation",
                  "type",
                  "schema",
                  "client"
              ]
          }
      },
      {
          "id": "recmbskAO4QDR4X7t",
          "createdTime": "2023-01-03T14:52:03.000Z",
          "fields": {
              "Term": "Output Type"
          }
      },
      {
          "id": "recnfE3ZRCltksvOi",
          "createdTime": "2023-01-03T14:59:49.000Z",
          "fields": {
              "Term": "Schema Stitching"
          }
      },
      {
          "id": "recnkYaPd6xmdEqlt",
          "createdTime": "2023-01-03T14:53:40.000Z",
          "fields": {
              "Term": "Edge"
          }
      },
      {
          "id": "recoVxL3bzy7mMS3Y",
          "createdTime": "2023-01-09T07:31:42.000Z",
          "fields": {
              "Description": "The execution engine is responsible for executing the GraphQL query by calling the appropriate resolvers and combining the results into a single response. It also applies any transformations or data manipulation that is specified in the query.\n",
              "Term": "Execution Engine"
          }
      },
      {
          "id": "recrGzS5xTQlH9b8B",
          "createdTime": "2023-01-03T14:51:38.000Z",
          "fields": {
              "Term": "Union Type"
          }
      },
      {
          "id": "recvHyJfbWhkw1ROE",
          "createdTime": "2023-01-03T14:54:52.000Z",
          "fields": {
              "Term": "Pagination"
          }
      },
      {
          "id": "recwweeY3UBbiKs21",
          "createdTime": "2023-01-04T14:00:56.000Z",
          "fields": {
              "Example": "scalar DateTime\n\ntype Cake {\n  id: ID!\n  name: String!\n  price: Float\n  available: Boolean!\n  hasFrosting: Boolean!\n  hasFilling: Boolean!\n  hasToppingOption: Boolean!\n  toppingKind: String\n  whenCreated: DateTime!\n  lastUpdated: DateTime!\n  }\n",
              "Description": "The most common custom scalar type in GraphQL schemas is DateTime, because it isn't a built-in scalar or described in the specification. Custom Scalars can also be used to define other units of measure or whatever is needed by a given implementation.\n",
              "Term": "Custom Scalar Type",
              "Tags": [
                  "scalars",
                  "schema",
                  "type"
              ]
          }
      },
      {
          "id": "recx8gUm84Gm1FQYy",
          "createdTime": "2023-01-03T14:51:21.000Z",
          "fields": {
              "Example": "\n",
              "Description": "Types describe the objects that are part of your GraphQL schema. There are eight types defined by the GraphQL specification.\n",
              "Term": "Types",
              "Tags": [
                  "graphql",
                  "type"
              ]
          }
      },
      {
          "id": "recyRSsAJ8ERXkl7L",
          "createdTime": "2023-01-04T14:29:07.000Z",
          "fields": {
              "Example": "\"\"\"fragment definition examples\"\"\"\nfragment UserFields on User {\n   id\n   name\n   email\n}\nquery GetUsers {\n   users {\n    ...UserFields\n }\n}\n\nfragment UserFields on User {\n id\n name\n email\n avatar(size: $avatarSize)\n}\n\nquery GetUsers($avatarSize: Int!) {\n users {\n  ...UserFields\n }\n}\n\n",
              "Description": "In GraphQL, a fragment is a reusable piece of a GraphQL query that can be shared among multiple queries. It allows you to specify a set of fields that you want to retrieve, and then include those fields in any query that needs them.\nFragments provide the ability to send several queries in one request this capability is a key to reducing the number of round trips to the server to fetch data.\n",
              "Term": "Fragments",
              "Tags": [
                  "schema",
                  "field-level"
              ]
          }
      },
      {
          "id": "recyUcFCFb4yKi8Si",
          "createdTime": "2023-02-09T13:54:49.000Z",
          "fields": {
              "Description": "Persisted queries are pre-registered all required queries of our clients. This can be done by extracting the queries of our client applications at build time and placing them in the server's query storage.\n",
              "Term": "Persisted Queries"
          }
      },
      {
          "id": "reczw5lFH1wi4x30S",
          "createdTime": "2023-01-03T14:55:48.000Z",
          "fields": {
              "Term": "Router"
          }
      }
  ]
}